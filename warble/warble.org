#+TITLE: Warble
* Overview
Successor to @!(ref "whistle")!@. A slightly
more complex sonic mechanism with a bit more points of
articulation.

This mechanism features a classic FM pair oscillator with
feedback at its core, aspiration noise with enveloped
articulation, an amplitude envelope, and vibrato control.

The goal of Warble is to provide a variety of behavorial
timbres: chiffs, hisses, singing, and chitters.
* Tangled file
Tangles to =warble/warble.lua=.

#+NAME: warble.lua
#+BEGIN_SRC lua :tangle warble/warble.lua
Warble = {}
<<warble>>
return Warble
#+END_SRC
* Graph Generator
=Warble.graph= will return a graph constructed with @!(
ref "diagraf")!@.

#+NAME: warble
#+BEGIN_SRC lua
function Warble.graph(params)
    local core = params.core or core
    local sr = params.sr or sigrunes
    local diagraf = params.diagraf or diagraf
    local sig = params.sig or sig

    local nd = sr.node
    local ln = core.liln
    local lf = core.lilf
    local plf = core.plilf

    local g = diagraf.Graph:new{sig=sig}

    g.init = function(grf)
        lil("gensine [tabnew 8192]")
        lil("param [regnxt 0]")
        local tab = pop()
        lil(string.format("regset zz %d; regmrk %d", tab, tab))
        grf.data = {}
        grf.data.tab = tab
    end

    local sintab = function(node, eval)
        eval = eval or lil
        local grf = node.data.g
        local tab = grf.data.tab
        eval(string.format("regget %d", tab))
    end

    ng  = core.nodegen(diagraf.Node, g)
    pg  = core.paramgen(ng)
    con = g:connector()
    prmf = core.paramf
    local p = params

    local pitch = pg(p.pitch or prmf(60), "pitch")
    local mi = pg(p.mi or prmf(1), "mod index")
    local car = pg(p.car or prmf(1), "car")
    local mod = pg(p.mod or prmf(1), "mod")
    local fdbk = pg(p.fdbk or prmf(0), "feedback")

    local pasp = p.asp or {}
    local asp = pg(pasp.val or prmf(0), "aspiration")
    local asp_gt = pg(pasp.gate or prmf(0), "aspiration gate")
    local asp_atk = pg(pasp.atk or prmf(0.1), "aspiration attack")
    local asp_rel = pg(pasp.rel or prmf(0.1), "aspiration release")

    local pamp = p.amp or {}
    local amp = pg(pamp.val or prmf(1), "amp")
    local a_gt = pg(pamp.gate or prmf(0), "amp gate")
    local a_atk = pg(pamp.atk or prmf(0.1), "amp attack")
    local a_rel = pg(pamp.rel or prmf(0.1), "amp release")
    local a_dur = pg(pamp.dur or prmf(0.1), "amp env duration")

    local pvib = p.vib or {}
    local vib_rate = pg(pvib.rate or prmf(6), "vibrato rate")
    local vib_depth = pg(pvib.depth or prmf(0.2), "vibrato depth")

    local fm = ng(sr.fmpair) {tab = sintab}

    con(mi, fm.mi)
    con(car, fm.car)
    con(mod, fm.mod)
    con(fdbk, fm.fdbk)

    local scaler = ng(sr.scale)

    local mul = ng(sr.mul)
    local add = ng(sr.add)
    local nz = ng(sr.noise)()
    local lpf = ng(sr.butlp)()
    local hpf = ng(sr.buthp){cutoff=300}
    con(nz, hpf.input)
    con(hpf, lpf.input)
    local freqmul = add{b = 12.0}
    con(pitch, freqmul.a)
    local mtof = ng(sr.mtof)
    local lpf_freq = mtof()
    con(freqmul, lpf_freq.input)
    con(lpf_freq, lpf.cutoff)

    local envar = ng(sr.envar)

    local cf = ng(sr.crossfade) {}

    local cfenv = envar {}

    local sclcf = scaler {max = 1.0}

    con(asp_rel, cfenv.rel)
    con(asp_atk, cfenv.atk)
    con(asp_gt, cfenv.gate)
    con(asp, sclcf.min)
    con(cfenv, sclcf.input)
    con(sclcf, cf.pos)

    con(fm, cf.a)
    con(lpf, cf.b)

    local generator = cf

    lfo = ng(sr.osc) {
        tab = sintab
    }

    con(vib_rate, lfo.freq)
    con(vib_depth, lfo.amp)

    vib = add()
    fm_freq = mtof()
    con(pitch, vib.a)
    con(lfo, vib.b)
    con(vib, fm_freq.input)
    con(fm_freq, fm.freq)

    sclamp = scaler {
        max = 1.0
    }

    con(amp, sclamp.min)

    ampenv = envar {}

    con(a_atk, ampenv.atk)
    con(a_rel, ampenv.rel)
    
    tgate = ng(sr.tgate)
    gtick = ng(sr.gtick)

    ampenv_gtick = gtick()
    ampenv_tgate = tgate()
    con(a_gt, ampenv_gtick.gate)
    con(ampenv_gtick, ampenv_tgate.trig)
    con(a_dur, ampenv_tgate.dur)

    ampenv_gt = ampenv_tgate
    con(ampenv_gt, ampenv.gate)
    con(ampenv, sclamp.input)

    local ascl_mul = mul()
    con(generator, ascl_mul.a)
    con(sclamp, ascl_mul.b)

    g.cleanup = function(grf)
        local tab = grf.data.tab
        grf.eval(string.format("regclr %d", tab))
    end
    return g
    end
#+END_SRC
* Compute
Computes-in-place an instance of Warble.
* Node (WIP)
Encapsulates Warble inside of a Node, to be compatible
with @!(ref "diagraf")!@. It follows an interface similar
to the nodes found in @!(ref "sigrunes")!@

NOTE: this needs some thought, as embedding a graph inside
of a node inside of another graph hasn't been done before.

#+NAME: warble
#+BEGIN_SRC lua
function Warble.node(n, p)
    error("TODO: still thinking how this will work.")
end
#+END_SRC
