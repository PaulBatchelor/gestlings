#+TITLE: The Gesture Path
* Overview
This document implements a Lua interface for create Gesture
Paths for Gesture VM. Paths constructed in Lua eventually
get generated into @!(ref "tal")!@ code.
* What's a "Path"?
A *path* is a construct used to describe Gestures. This
is a term borrowed from computer science and graph
theory. A path
can be described as a sequential set of vertices,
connected together by edges. In this context,
a vertice can be thought of as a set of state parameters
for the Gesture Signal Generator: value, behavior, and
rate multiplier. Alternatively, one could also imagine
edges as being weighted by the rate multiplier, but at
the time of writing there hasn't been any usecase for
doing it this way.

A path is said to be *linear* if the vertices flow in
one single direction. A path becomes *non-linear* when this
flow is interrupted somehow, such as with branching.
* Tangled Code
#+NAME: path.lua
#+BEGIN_SRC lua :tangle path/path.lua
local Path = {}
<<path>>
return Path
#+END_SRC
* Creating a Vertex
The =vertex= function creates a gesture vertex, represented
as a lua table. The input is an array of 3 values: value,
duration, and behavior.

Duration is itself a 2-element array containing the numerator
and denominator values for the rate multiplier.

Behavior is an integer value indicating the type of behavior
to be used. See the @!(ref
"gest" "gest behavior constants"
"behavior_constants")!@ for some human-friendly variable
names to use instead of just numbers.

#+NAME: path
#+BEGIN_SRC lua
function Path.vertex(v)
    x = {}

    x.val = v[1]
    x.dur = v[2]
    x.bhvr = v[3]

    return x
end
#+END_SRC
* Compiling a Path
A Path, represented as an array of Gesture vertices in
Lua, can be compiled into TAL code using the =path=
function. In addition to the path to be compiled,
the @!(ref "tal")!@ library will need to be passed in,
along with a table to place the words that get generated.

#+NAME: path
#+BEGIN_SRC lua
function Path.path(tal, words, path)
    for _, v in pairs(path)
    do
        if v.val ~= nil then
            tal.val(words, v.val)
        end

        if v.dur ~= nil then
            tal.dur(words, v.dur[1], v.dur[2])
        end

        if v.bhvr ~= nil then
            tal.behavior(words, v.bhvr)
        end
    end
end

#+END_SRC
* Saving/Loading Paths as Assets
Requires an instantiated @!(ref "asset")!@ component.

#+NAME: path
#+BEGIN_SRC lua
function Path.save(asset, gpath, filename)
    asset:save(gpath, filename)
end

function Path.load(asset, filename)
    local path_data = asset:load(filename)

    local gpath = {}
    for _,v in pairs(path_data) do
        table.insert(gpath, Path.vertex(v))
    end

    return gpath
end
#+END_SRC
* Symbol Set and Grammar
For the symbol set, see @!(ref "path_symbols")!@.
The corresponding grammar can be found
at @!(ref "path_grammar")!@.
* AST to Path
Converts an abstract syntax tree generated from the @!(
ref "path_grammar)!@ into an actual path.
#+NAME: path
#+BEGIN_SRC lua
function Path.AST_to_path(t)
    behaviors = {
        linear = 0,
        step = 1,
        gliss_medium = 2,
        gliss_large = 3,
        gliss_small = 4,
    }

    local ratemul = {1, 1}
    local behavior = behaviors["linear"]
    local gpath = {}

    for _,v in pairs(t) do
        local val = tonumber("0x" .. v.value[1] .. v.value[2])
        if v.behavior ~= nil then
            behavior = behaviors[v.behavior]
        end

        if v.ratemul ~= nil then
            if #v.ratemul == 2 then
                local num, den
                num = v.ratemul[1]
                num = tonumber("0x" .. num[1] .. num[2])
                den = v.ratemul[2]
                den = tonumber("0x" .. den[1] .. den[2])
                ratemul = {num, den}
            elseif #v.ratemul == 1 then
                local num, den
                num = v.ratemul[1]
                num = tonumber("0x" .. num[1] .. num[2])
                ratemul = {num}
            end
        end
        local vertex = {
            val,
            ratemul,
            behavior
        }
        table.insert(gpath, vertex)
    end
    return gpath
end
#+END_SRC
