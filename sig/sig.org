#+TITLE: Sig
* Overview/Top
This module contains helper functions that assist in signal management
in sndkit.

=signal management= refers to any non-trivial use of a signal that
requires manual intervention. In sndkit, signals become "non-trivial"
quite quickly; any signal that wants to be used more than once in a way
that can't be done using stack operations can be considered non-trivial.
 
#+NAME: sig.lua
#+BEGIN_SRC lua :tangle sig/sig.lua
Sig = {}
<<sig>>
return Sig
#+END_SRC
* New
Creates a new instance of a signal.

#+NAME: sig
#+BEGIN_SRC lua
function Sig:new(o)
    o = o or {}
    o.reg = -1
    setmetatable(o, self)
    self.__index = self
    return o
end
#+END_SRC
* Hold
Takes the last item off the buffer stack, holds it,
and then stores it in a free register.

=lil_eval= is an optional callback that can replace the
default =lil= evaluator. It can be used for debugging
purposes. Usually something like =print= would be used.

Not that in order for the register marking to work,
actual lil code must be evaluated. These bits of code
are always actually called by =lil=, and will also
be called by =lil_eval= if they are different functions.

#+NAME: sig
#+BEGIN_SRC lua
function Sig:hold(lil_eval)
    -- can be a callback used to simulate holding
    lil_eval = lil_eval or lil
    if self.reg >= 0 then
        error("can't hold, already holding")
    end

    -- regnxt actually has to be called to see if it is
    -- working

    local lstr = "param [regnxt 0]"
    -- if lil_eval ~= lil then
    --     lil_eval(lstr)
    -- end

    lil(lstr)


    local reg = pop()

    if reg < 0 then
        error("invalid index")
    end

    -- hold/regset can be simulated without issue
    lil_eval("hold zz")
    lil_eval(string.format("regset zz %d", reg))

    -- regmrk actually has to be called for it to work
    local lstr = string.format("regmrk %d", reg)

    if lil_eval ~= lil then
        lil_eval(lstr)
    end

    lil(lstr)
    -- lil(string.format("regset zz %d; regmrk %d", reg, reg))

    self.reg = reg
end
#+END_SRC
* Unhold
Unholds the underlying signal (buffer), if there is one
to be unheld.

Just like =hold=, =lil_eval= is a an optional function
that overrides the default =lil= evaluator, and was
originally used for debugging purposes.

#+NAME: sig
#+BEGIN_SRC lua
function Sig:unhold(lil_eval)
    lil_eval = lil_eval or lil
    if self.reg < 0 then
        error("no signal to unhold")
    end

    lil_eval(string.format("unhold [regget %d]; regclr %d",
        self.reg, self.reg))

    self.reg = -1
end
#+END_SRC
* Get
Gets the signal and pushes it onto the buffer stack.

#+NAME: sig
#+BEGIN_SRC lua
function Sig:get()
    if self.reg < 0 then
        error("no signal")
    end

    lil(string.format("regget %d", self.reg))
end
#+END_SRC
* Getstr
This returns the string of LIL code that, once evaluated,
would push the signal onto the stack.

#+NAME: sig
#+BEGIN_SRC lua
function Sig:getstr()
    if self.reg < 0 then
        error("no signal")
    end

    return string.format("[regget %d]", self.reg)
end
#+END_SRC
* zero
Creates and holds an auxilliary cable to be used for
sends and throws. It starts of with no signal, hence
the name "zero".

#+NAME: sig
#+BEGIN_SRC lua
function Sig:zero()
    if self.reg >= 0 then
        error("A signal is already being held")
    end
    lil("zero")
    self.hold(self)
end
#+END_SRC
* Send
Pops the last signal off the stack and mixes it into
the internal cable.

"Gain" is a attenuation value in db units. By default
it is 0 (full scale).

#+NAME: sig
#+BEGIN_SRC lua
function Sig:send(gain)
    if self.reg < 0 then
        error("no signal")
    end

    gain = gain or 0

    lil(string.format("mix zz [regget %d] [dblin %g]",
        self.reg, gain))
end
#+END_SRC
* Throw
Like send, but instead of popping the signal off the stack,
it dups it first, keeping a copy of the signal on
the stack.

#+NAME: sig
#+BEGIN_SRC lua
function Sig:throw(gain)
    if self.reg < 0 then
        error("no signal")
    end

    lil("dup")
    self.send(self, gain)
end
#+END_SRC
